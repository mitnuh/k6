package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type ElemInfo struct {
	ConstName     string
	StructName    string
	PrtStructName string
}

type NodeHandler func(node ast.Node) NodeHandler

type CollectElements struct {
	handler   NodeHandler
	elemName  string
	elemInfos map[string]*ElemInfo
}

type FuncDef struct {
	ElemName   string
	ElemMethod string
	AttrMethod string
	AttrName   string
	ReturnType string
}

var funcDefs = []string{
	"Href Rel string",
	"Href Href string",
	"Href Target string",
	"Href Type string",
	"Href AccessKey string",
	"Href HrefLang string",
	"Href Media string",
	"Href ToString=href string",
	"Href Href string",

	"Base Href bool",
	"Base Target bool",

	"Button AccessKey string",
	"Button Autofocus bool",
	"Button Disabled bool",
}

type TestDef struct {
	ElemStructName string
	ElemHtmlName   string
	ElemMethod     string
	AttrName       string
	AttrVal        string
}

var testDefs = []string{
	//Element MethodToTest AttrVal
	"Area rel relattrval",
	"Area href hrefattrval",
	"Area toString href=hrefval",
	"Base autofocus true",
	"Button accessKey q",
	"Button autofocus true",
	"Button disabled true",
}

func main() {
	fs := token.NewFileSet()
	parsedFile, parseErr := parser.ParseFile(fs, "elements.go", nil, 0)
	if parseErr != nil {
		log.Fatalf("warning: internal error: could not parse elements.go: %s", parseErr)
		return
	}

	ce := &CollectElements{}
	ce.handler = ce.defaultHandler
	ce.elemInfos = make(map[string]*ElemInfo)

	ast.Inspect(parsedFile, func(n ast.Node) bool {
		if n != nil {
			ce.handler = ce.handler(n)
		}
		return true
	})

	f, err := os.Create("elements_gen.go")
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}

	elemFuncsTemplate.Execute(f, struct {
		ElemInfos map[string]*ElemInfo
		FuncDefs  []string
	}{
		ce.elemInfos,
		funcDefs,
	})
	f.Close()

	f, err = os.Create("elements_gen_test.go")
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}

	testFuncTemplate.Execute(f, struct {
		TestDefs []string
	}{
		testDefs,
	})
	f.Close()
}

var elemFuncsTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"buildStruct":  buildStruct,
	"buildFuncDef": buildFuncDef,
}).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html

func selToElement(sel Selection) goja.Value {
	if sel.sel.Length() == 0 {
		return goja.Undefined()
	}

	elem := Element{sel.sel.Nodes[0], &sel}

	switch elem.node.Data { {{ range $elemInfo := .ElemInfos }}
	case {{ $elemInfo.ConstName }}:
		return sel.rt.ToValue({{ buildStruct $elemInfo }})
	{{ end }}
	default:
		return sel.rt.ToValue(elem)
	}
 }

{{ range $funcDefStr := .FuncDefs }} {{ $funcDef := buildFuncDef $funcDefStr }}
func (e {{$funcDef.ElemName}}) {{$funcDef.ElemMethod}}() {{$funcDef.ReturnType}} {
	return e.{{ $funcDef.AttrMethod }}("{{ $funcDef.AttrName }}")
}
{{ end }}
`))

var testFuncTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"buildTestDef": buildTestDef,
}).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html

import (
	"context"
	"testing"

	"github.com/dop251/goja"
	"github.com/loadimpact/k6/js/common"
	"github.com/stretchr/testify/assert"
)

const testGenElems = ` + "`" + `<html><body>
{{ range $index, $testDefStr := .TestDefs }} {{ $def := buildTestDef $testDefStr }}
<{{$def.ElemHtmlName}} id="elem_{{$index}}" {{$def.AttrName}}={{$def.AttrVal}}></{{ $def.ElemHtmlName }}> {{ end }}
</body></html>` + "`" + `

func TestGenElements(t *testing.T) {
	rt := goja.New()
	rt.SetFieldNameMapper(common.FieldNameMapper{})

	ctx := common.WithRuntime(context.Background(), rt)
	rt.Set("src", testHTMLElems)
	rt.Set("html", common.Bind(rt, &HTML{}, &ctx))
	// compileProtoElem()

	_, err := common.RunString(rt, "let doc = html.parseHTML(src)")

	assert.NoError(t, err)
	assert.IsType(t, Selection{}, rt.Get("doc").Export())
{{ range $index, $testDefStr := .TestDefs }} {{ $def := buildTestDef $testDefStr }} 
	t.Run("{{$def.ElemStructName}} {{$def.ElemMethod}}", func(t *testing.T) {
		if v, err := common.RunString(rt, "doc.find(\"#elem_{{$index}}\").get(0).{{$def.ElemMethod}}()"); assert.NoError(t, err) {
				assert.Equal(t, {{$def.AttrVal}}, v.Export())
		}
	})
{{ end }}
}
`))

func buildStruct(elemInfo ElemInfo) string {
	if elemInfo.PrtStructName == "Element" {
		return elemInfo.StructName + "{elem}"
	} else {
		return elemInfo.StructName + "{" + elemInfo.PrtStructName + "{elem}}"
	}
}

func buildFuncDef(funcDef string) FuncDef {
	parts := strings.Split(funcDef, " ")
	// parts[0] is the element struct name (without the Element suffix for brevity)
	// parts[1] is either:
	//   MethodName               The name of method added onto that struct and converted to lowercase thenn used as the argument to elem.attrAsString(...) or elem.AttrIsPresent(...)
	//   MethodName=attrname      The MethodName is added to the struct. The attrname is the argument for attrAsString or AttrIsPresent
	// parts[2] is the return type, either string or bool
	elemName := parts[0] + "Element"
	elemMethod := parts[1]
	attrName := strings.ToLower(parts[1])
	returnType := parts[2]

	if eqPos := strings.Index(parts[1], "="); eqPos != -1 {
		attrName = elemMethod[eqPos+1:]
		elemMethod = elemMethod[0:eqPos]
	}

	switch returnType {
	case "string":
		// "Button AccessKey string" => {"ButtonElement" "AccessKey", "attrIsString", "accesskey", "string"} => `func (e ButtonElement) AccessKey() string{ return e.attrAsString("accessKey") }``
		// "Href ToString=href string" => {"HrefElement" "ToString", "attrIsString", "href", "string"} => `func (e HrefElement) ToString() string { return e.textContent("href") }``
		return FuncDef{elemName, elemMethod, "attrAsString", attrName, returnType}
	case "bool":
		// "Button Autofocus bool" {"Button" "Autofocus", "attrIsPresent", "autofocus", "bool"} => `func (e ButtonElement) ToString() bool { return e.attrIsPresent("autofocus") }``
		return FuncDef{elemName, elemMethod, "attrIsPresent", attrName, returnType}
	default:
		panic("Unknown attrType in a funcDef")
	}
}

func buildTestDef(testDef string) TestDef {
	parts := strings.Split(testDef, " ")

	elemStructName := parts[0] + "Element"
	elemHtmlName := strings.ToLower(parts[0])
	elemMethod := parts[1]
	attrName := strings.ToLower(parts[1])
	attrVal := parts[2]

	if eqPos := strings.Index(attrVal, "="); eqPos != -1 {
		attrName = attrVal[0:eqPos]
		attrVal = attrVal[eqPos+1:]
	}

	if attrVal != "true" {
		attrVal = "\"" + attrVal + "\""
	}

	return TestDef{elemStructName, elemHtmlName, elemMethod, attrName, attrVal}
}

// Node handler functions used in ast.Inspect to scrape TagName consts and the names of Element structs and their parent/nested struct

func (ce *CollectElements) defaultHandler(node ast.Node) NodeHandler {
	ce.elemName = ""

	switch node.(type) {
	case *ast.TypeSpec:
		return ce.elemTypeSpecHandler

	case *ast.ValueSpec:
		return ce.tagNameValueSpecHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) tagNameValueSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if strings.HasSuffix(x.Name, "TagName") {
			elemName := strings.TrimSuffix(x.Name, "TagName")
			ce.elemInfos[elemName] = &ElemInfo{x.Name, "", ""}
		}

		return ce.defaultHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) elemTypeSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if !strings.HasSuffix(x.Name, "Element") {
			return ce.defaultHandler
		}

		if ce.elemName == "" {
			ce.elemName = strings.TrimSuffix(x.Name, "Element")
			// Ignore HrefElement and MediaElement structs. They are subclassed by AnchorElement/AreaElement/VideoElement and do not have their own entry in ElemInfos
			if _, ok := ce.elemInfos[ce.elemName]; !ok {
				return ce.defaultHandler
			}

			ce.elemInfos[ce.elemName].StructName = x.Name
			return ce.elemTypeSpecHandler
		} else {
			ce.elemInfos[ce.elemName].PrtStructName = x.Name
			return ce.defaultHandler
		}

	case *ast.StructType:
		return ce.elemTypeSpecHandler

	case *ast.FieldList:
		return ce.elemTypeSpecHandler

	case *ast.Field:
		return ce.elemTypeSpecHandler

	default:
		return ce.defaultHandler
	}
}
