package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"
)

type ElemInfo struct {
	ConstName     string
	StructName    string
	PrtStructName string
}

type NodeHandler func(node ast.Node) NodeHandler

type CollectElements struct {
	handler   NodeHandler
	elemName  string
	elemInfos map[string]*ElemInfo
}

type FuncDef struct {
	ElemName   string
	ElemMethod string
	AttrMethod string
	AttrName   string
	ReturnType string
}

var funcDefs = []string{
	"Href Rel string",
	"Href Href string",
	"Href Target string",
	"Href Type string",
	"Href AccessKey string",
	"Href HrefLang string",
	"Href Media string",
	"Href ToString=href string",

	"Base Href bool",
	"Base Target bool",

	"Button AccessKey string",
	"Button Autofocus bool",
	"Button Disabled bool",

	"Data Value string",

	"Embed Height string",
	"Embed Width string",
	"Embed Src string",
	"Embed Type string",

	"FieldSet Disabled bool",
	"FieldSet Name string",
}

type TestDef struct {
	ElemHtmlName string
	ElemMethod   string
	AttrName     string
	AttrVal      string
}

func main() {
	fs := token.NewFileSet()
	parsedFile, parseErr := parser.ParseFile(fs, "elements.go", nil, 0)
	if parseErr != nil {
		log.Fatalf("warning: internal error: could not parse elements.go: %s", parseErr)
		return
	}

	ce := &CollectElements{}
	ce.handler = ce.defaultHandler
	ce.elemInfos = make(map[string]*ElemInfo)

	ast.Inspect(parsedFile, func(n ast.Node) bool {
		if n != nil {
			ce.handler = ce.handler(n)
		}
		return true
	})

	f, err := os.Create("elements_gen.go")
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}

	elemFuncsTemplate.Execute(f, struct {
		ElemInfos map[string]*ElemInfo
		FuncDefs  []string
	}{
		ce.elemInfos,
		funcDefs,
	})
	f.Close()

	f, err = os.Create("elements_gen_test.go")
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}

	testFuncTemplate.Execute(f, struct {
		FuncDefs []string
	}{
		funcDefs,
	})
	f.Close()
}

var elemFuncsTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"buildStruct":  buildStruct,
	"buildFuncDef": buildFuncDef,
}).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html

import "github.com/dop251/goja"

func selToElement(sel Selection) goja.Value {
	if sel.sel.Length() == 0 {
		return goja.Undefined()
	}

	elem := Element{sel.sel.Nodes[0], &sel}

	switch elem.node.Data { {{ range $elemInfo := .ElemInfos }}
	case {{ $elemInfo.ConstName }}:
		return sel.rt.ToValue({{ buildStruct $elemInfo }})
	{{ end }}
	default:
		return sel.rt.ToValue(elem)
	}
 }

{{ range $funcDefStr := .FuncDefs }} {{ $funcDef := buildFuncDef $funcDefStr }}
func (e {{$funcDef.ElemName}}) {{$funcDef.ElemMethod}}() {{$funcDef.ReturnType}} {
	return e.{{ $funcDef.AttrMethod }}("{{ $funcDef.AttrName }}")
}
{{ end }}
`))

var testFuncTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"buildTestDef": buildTestDef,
}).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html

import (
	"context"
	"testing"

	"github.com/dop251/goja"
	"github.com/loadimpact/k6/js/common"
	"github.com/stretchr/testify/assert"
)

const testGenElems = ` + "`" + `<html><body>
{{ range $index, $testDefStr := .FuncDefs }} {{ $def := buildTestDef $index $testDefStr }}
<{{$def.ElemHtmlName}} id="elem_{{$index}}"{{ if eq $def.AttrVal "true" }} {{$def.AttrName}} {{else}} {{$def.AttrName}}="{{$def.AttrVal}}" {{end}}></{{ $def.ElemHtmlName }}> {{ end }}
</body></html>` + "`" + `

func TestGenElements(t *testing.T) {
	rt := goja.New()
	rt.SetFieldNameMapper(common.FieldNameMapper{})

	ctx := common.WithRuntime(context.Background(), rt)
	rt.Set("src", testGenElems)
	rt.Set("html", common.Bind(rt, &HTML{}, &ctx))
	// compileProtoElem()

	_, err := common.RunString(rt, "let doc = html.parseHTML(src)")

	assert.NoError(t, err)
	assert.IsType(t, Selection{}, rt.Get("doc").Export())
{{ range $index, $testDefStr := .FuncDefs }} {{ $def := buildTestDef $index $testDefStr }} 
	t.Run("{{$def.ElemHtmlName}}.{{$def.ElemMethod}}", func(t *testing.T) {
		if v, err := common.RunString(rt, "doc.find(\"#elem_{{$index}}\").get(0).{{$def.ElemMethod}}()"); assert.NoError(t, err) {
				assert.Equal(t, {{ if eq $def.AttrVal "true" }}{{$def.AttrVal}} {{else}} "{{$def.AttrVal}}" {{end}}, v.Export())
		}
	})
{{ end }}
}
`))

func buildStruct(elemInfo ElemInfo) string {
	if elemInfo.PrtStructName == "Element" {
		return elemInfo.StructName + "{elem}"
	} else {
		return elemInfo.StructName + "{" + elemInfo.PrtStructName + "{elem}}"
	}
}

func buildFuncDef(funcDef string) FuncDef {
	parts := strings.Split(funcDef, " ")
	// parts[0] is the element struct name (without the Element suffix for brevity)
	// parts[1] is either:
	//   MethodName               The name of method added onto that struct and converted to lowercase thenn used as the argument to elem.attrAsString(...) or elem.AttrIsPresent(...)
	//   MethodName=attrname      The MethodName is added to the struct. The attrname is the argument for attrAsString or AttrIsPresent
	// parts[2] is the return type, either string or bool
	elemName := parts[0] + "Element"
	elemMethod := parts[1]
	attrName := strings.ToLower(parts[1])
	returnType := parts[2]

	if eqPos := strings.Index(parts[1], "="); eqPos != -1 {
		attrName = elemMethod[eqPos+1:]
		elemMethod = elemMethod[0:eqPos]
	}

	switch returnType {
	case "string":
		// "Button AccessKey string" => {"ButtonElement" "AccessKey", "attrIsString", "accesskey", "string"} => `func (e ButtonElement) AccessKey() string{ return e.attrAsString("accessKey") }``
		// "Href ToString=href string" => {"HrefElement" "ToString", "attrIsString", "href", "string"} => `func (e HrefElement) ToString() string { return e.textContent("href") }``
		return FuncDef{elemName, elemMethod, "attrAsString", attrName, returnType}
	case "bool":
		// "Button Autofocus bool" {"Button" "Autofocus", "attrIsPresent", "autofocus", "bool"} => `func (e ButtonElement) ToString() bool { return e.attrIsPresent("autofocus") }``
		return FuncDef{elemName, elemMethod, "attrIsPresent", attrName, returnType}
	default:
		panic("Unknown attrType in a funcDef")
	}
}

func buildTestDef(index int, testDef string) TestDef {
	parts := strings.Split(testDef, " ")

	elemHtmlName := strings.ToLower(parts[0])

	if elemHtmlName == "href" {
		elemHtmlName = "a"
	}

	elemMethod := strings.ToLower(parts[1][0:1]) + parts[1][1:]
	attrName := strings.ToLower(parts[1])

	if eqPos := strings.Index(elemMethod, "="); eqPos != -1 {
		attrName = elemMethod[eqPos+1:]
		elemMethod = elemMethod[0:eqPos]
	}

	if parts[2] == "bool" {
		return TestDef{elemHtmlName, elemMethod, attrName, "true"}
	} else {
		return TestDef{elemHtmlName, elemMethod, attrName, "attrval_" + strconv.Itoa(index)}
	}
}

// Node handler functions used in ast.Inspect to scrape TagName consts and the names of Element structs and their parent/nested struct

func (ce *CollectElements) defaultHandler(node ast.Node) NodeHandler {
	ce.elemName = ""

	switch node.(type) {
	case *ast.TypeSpec:
		return ce.elemTypeSpecHandler

	case *ast.ValueSpec:
		return ce.tagNameValueSpecHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) tagNameValueSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if strings.HasSuffix(x.Name, "TagName") {
			elemName := strings.TrimSuffix(x.Name, "TagName")
			ce.elemInfos[elemName] = &ElemInfo{x.Name, "", ""}
		}

		return ce.defaultHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) elemTypeSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if !strings.HasSuffix(x.Name, "Element") {
			return ce.defaultHandler
		}

		if ce.elemName == "" {
			ce.elemName = strings.TrimSuffix(x.Name, "Element")
			// Ignore HrefElement and MediaElement structs. They are subclassed by AnchorElement/AreaElement/VideoElement and do not have their own entry in ElemInfos
			if _, ok := ce.elemInfos[ce.elemName]; !ok {
				return ce.defaultHandler
			}

			ce.elemInfos[ce.elemName].StructName = x.Name
			return ce.elemTypeSpecHandler
		} else {
			ce.elemInfos[ce.elemName].PrtStructName = x.Name
			return ce.defaultHandler
		}

	case *ast.StructType:
		return ce.elemTypeSpecHandler

	case *ast.FieldList:
		return ce.elemTypeSpecHandler

	case *ast.Field:
		return ce.elemTypeSpecHandler

	default:
		return ce.defaultHandler
	}
}
