package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type ElemInfo struct {
	ConstName     string
	StructName    string
	PrtStructName string
}

type FuncDef struct {
	ElemName   string
	ElemMethod string
	AttrMethod string
	AttrArg    string
	ReturnType string
}

type NodeHandler func(node ast.Node) NodeHandler

type CollectElements struct {
	handler   NodeHandler
	elemName  string
	elemInfos map[string]*ElemInfo
}

var attrFuncDefs = []string{
	"Href Rel string",
	"Href Href string",
	"Href ToString=href string",
	"Base Autofocus bool",
	"Button AccessKey string",
	"Button Autofocus string",
	"Button Disabled string",
}

var testFuncDefs = []string{
	//Element MethodToTest AttrName=AttrVal
	"Anchor Rel relattrval",
	"Anchor Href hrefattrval",
	"Anchor ToString href=hrefval",
	"Base Autofocus true",
	"Button AccessKey q",
	"Button Autofocus true",
	"Button Disabled string",
}

func main() {
	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, "elements.go", nil, 0)

	if err != nil {
		log.Fatalf("warning: internal error: could not parse elemts.go: %s", err)
		return
	}

	ce := &CollectElements{}
	ce.handler = ce.defaultHandler
	ce.elemInfos = make(map[string]*ElemInfo)

	ast.Inspect(parsedFile, func(n ast.Node) bool {
		if n != nil {
			ce.handler = ce.handler(n)
		}
		return true
	})

	f, err := os.Create("elements_gen.go")
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}
	elemsTemplate.Execute(f, struct {
		ElemInfos    map[string]*ElemInfo
		AttrFuncDefs []string
	}{
		ce.elemInfos,
		attrFuncDefs,
	})
	f.Close()
}

var elemsTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"buildStruct":  buildStruct,
	"buildFuncDef": buildFuncDef,
}).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html

func selToElement(sel Selection) goja.Value {
	if sel.sel.Length() == 0 {
		return goja.Undefined()
	}

	elem := Element{sel.sel.Nodes[0], &sel}
	
	switch elem.node.Data { {{ range $elemInfo := .ElemInfos }} 
	case {{ $elemInfo.ConstName }}:
		return sel.rt.ToValue({{ buildStruct $elemInfo }})
	{{ end }} 
	default:
		return sel.rt.ToValue(elem)
	}
}

{{ range $funcDefStr := .AttrFuncDefs }} {{ $funcDef := buildFuncDef $funcDefStr }}
func (e {{$funcDef.ElemName}}) {{$funcDef.ElemMethod}}() {{$funcDef.ReturnType}} {
	return e.{{ $funcDef.AttrMethod }}("{{ $funcDef.AttrArg }}")
}
{{ end }}
`))

// Build fragments for the template
func buildStruct(elemInfo ElemInfo) string {
	if elemInfo.PrtStructName == "Element" {
		return elemInfo.StructName + "{elem}"
	} else {
		return elemInfo.StructName + "{" + elemInfo.PrtStructName + "{elem}}"
	}
}

func buildFuncDef(funcDef string) FuncDef {
	parts := strings.Split(funcDef, " ")
	// parts[0] is the element struct name (without the Element suffix for brevity)
	// parts[1] is either:
	//   MethodName               The TitleCased name of method to add onto that struct.
	//                            The string is lowercased and given as an argment to elem.attrAsString(...) or elem.AttrIsPresent(...)
	//   MethodName=attrname      The MethodName is the name of the mehtid to add to the struct. The attrname is given, as is, to attrAsString ot AttrIsPresent
	// parts[2] is return type, either string or bool
	elemName := parts[0] + "Element"
	elemMethod := parts[1]
	attrName := strings.ToLower(parts[1])
	returnType := parts[2]

	if eqPos := strings.Index(parts[1], "="); eqPos != -1 {
		attrName = elemMethod[eqPos+1:]
		elemMethod = elemMethod[0:eqPos]
	}

	switch returnType {
	case "string":
		// "Button AccessKey string" => {"ButtonElement" "AccessKey", "attrIsString", "accesskey", "string"} => `func (e ButtonElement) AccessKey() string{ return e.attrAsString("accessKey") }``
		// "Href ToString=href string" => {"HrefElement" "ToString", "attrIsString", "href", "string"} => `func (e HrefElement) ToString() string { return e.textContent("href") }``
		return FuncDef{elemName, elemMethod, "attrAsString", attrName, returnType}
	case "bool":
		// "Button Autofocus bool" {"Button" "Autofocus", "attrIsPresent", "autofocus", "bool"} => `func (e ButtonElement) ToString() bool { return e.attrIsPresent("autofocus") }``
		return FuncDef{elemName, elemMethod, "attrIsPresent", attrName, returnType}
	default:
		panic("Unknown attrType in a funcDef")
	}
}

// Node handler functions used in ast.Inspect to scrape TagName consts and the names of Element structs and their parent/nested struct

func (ce *CollectElements) defaultHandler(node ast.Node) NodeHandler {
	ce.elemName = ""

	switch node.(type) {
	case *ast.TypeSpec:
		return ce.elemTypeSpecHandler

	case *ast.ValueSpec:
		return ce.tagNameValueSpecHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) tagNameValueSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if strings.HasSuffix(x.Name, "TagName") {
			elemName := strings.TrimSuffix(x.Name, "TagName")
			ce.elemInfos[elemName] = &ElemInfo{x.Name, "", ""}
		}

		return ce.defaultHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) elemTypeSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if !strings.HasSuffix(x.Name, "Element") {
			return ce.defaultHandler
		}

		if ce.elemName == "" {
			ce.elemName = strings.TrimSuffix(x.Name, "Element")
			// Ignore HrefElement and MediaElement structs. They are subclassed by AnchorElement/AreaElement/VideoElement and do not have their own entry in ElemInfos
			if _, ok := ce.elemInfos[ce.elemName]; !ok {
				return ce.defaultHandler
			}

			ce.elemInfos[ce.elemName].StructName = x.Name
			return ce.elemTypeSpecHandler
		} else {
			ce.elemInfos[ce.elemName].PrtStructName = x.Name
			return ce.defaultHandler
		}

	case *ast.StructType:
		return ce.elemTypeSpecHandler

	case *ast.FieldList:
		return ce.elemTypeSpecHandler

	case *ast.Field:
		return ce.elemTypeSpecHandler

	default:
		return ce.defaultHandler
	}
}
