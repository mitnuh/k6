package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type ElemInfo struct {
	ConstName     string
	StructName    string
	PrtStructName string
}

type FuncDef struct {
	ElemName     string
	PropertyName string
	ReturnType   string
}

type NodeHandler func(node ast.Node) NodeHandler

type CollectElements struct {
	handler   NodeHandler
	elemName  string
	elemInfos map[string]*ElemInfo
}

var attrFuncDefs = []string{
	"Href Rel string",
	"Area Href string",
	"Area AccessKey bool",
	"Base Autofocus string",
	"Button AccessKey string",
	"Button Autofocus string",
	"Button Disabled string",
}

func main() {
	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, "elements.go", nil, 0)

	if err != nil {
		log.Fatalf("warning: internal error: could not parse elemts.go: %s", err)
		return
	}

	ce := &CollectElements{}
	ce.handler = ce.defaultHandler
	ce.elemInfos = make(map[string]*ElemInfo)

	ast.Inspect(parsedFile, func(n ast.Node) bool {
		if n != nil {
			ce.handler = ce.handler(n)
		}
		return true
	})

	f, err := os.Create("elements_gen.go")
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}
	elemsTemplate.Execute(f, struct {
		ElemInfos    map[string]*ElemInfo
		AttrFuncDefs []string
	}{
		ce.elemInfos,
		attrFuncDefs,
	})
	f.Close()
}

var elemsTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"buildStruct":   buildStruct,
	"splitFuncDef":  splitFuncDef,
	"buildFuncBody": buildFuncBody,
	"toLower":       strings.ToLower,
}).Parse(`// go generate
// generated by js/modules/k6/html/gen/main.go directed by js/modules/k6/html/elements.go;  DO NOT EDIT
package html
func selToElement(sel Selection) goja.Value {
	if sel.sel.Length() == 0 {
		return goja.Undefined()
	}

	elem := Element{sel.sel.Nodes[0], &sel}
	
	switch elem.node.Data { {{ range $elemInfo := .ElemInfos }} 
	case {{ $elemInfo.ConstName }}:
		return sel.rt.ToValue({{ buildStruct $elemInfo }})
	{{ end }} 
	default:
		return sel.rt.ToValue(elem)
	}
}

{{ range $funcDefStr := .AttrFuncDefs }} {{ $funcDef := splitFuncDef $funcDefStr }}
func (e {{$funcDef.ElemName}}Element) {{$funcDef.PropertyName}}() {{$funcDef.ReturnType}} {
	return e.{{ buildFuncBody $funcDef }}("{{ toLower $funcDef.PropertyName }}")
}
{{ end }}
`))

// Build fragments for the template
func buildStruct(elemInfo ElemInfo) string {
	if elemInfo.PrtStructName == "Element" {
		return elemInfo.StructName + "{elem}"
	} else {
		return elemInfo.StructName + "{" + elemInfo.PrtStructName + "{elem}}"
	}
}

func splitFuncDef(funcDef string) FuncDef {
	parts := strings.Split(funcDef, " ")
	return FuncDef{parts[0], parts[1], parts[2]}
}

func buildFuncBody(funcDef FuncDef) string {
	switch funcDef.ReturnType {
	case "string":
		return `attrAsString`

	case "bool":
		return `attrIsPresent`

	default:
		panic("Unknown attrType in a funcDef")
	}
}

// Node handler functions used in ast.Inspect to scrape TagName consts and the names of Element structs and their parent/nested struct

func (ce *CollectElements) defaultHandler(node ast.Node) NodeHandler {
	ce.elemName = ""

	switch node.(type) {
	case *ast.TypeSpec:
		return ce.elemTypeSpecHandler

	case *ast.ValueSpec:
		return ce.tagNameValueSpecHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) tagNameValueSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if strings.HasSuffix(x.Name, "TagName") {
			elemName := strings.TrimSuffix(x.Name, "TagName")
			ce.elemInfos[elemName] = &ElemInfo{x.Name, "", ""}
		}

		return ce.defaultHandler

	default:
		return ce.defaultHandler
	}
}

func (ce *CollectElements) elemTypeSpecHandler(node ast.Node) NodeHandler {
	switch x := node.(type) {
	case *ast.Ident:
		if !strings.HasSuffix(x.Name, "Element") {
			return ce.defaultHandler
		}

		if ce.elemName == "" {
			ce.elemName = strings.TrimSuffix(x.Name, "Element")
			// Ignore HrefElement and MediaElement structs. They are subclassed by AnchorElement/AreaElement/VideoElement and do not have their own entry in ElemInfos
			if _, ok := ce.elemInfos[ce.elemName]; !ok {
				return ce.defaultHandler
			}

			ce.elemInfos[ce.elemName].StructName = x.Name
			return ce.elemTypeSpecHandler
		} else {
			ce.elemInfos[ce.elemName].PrtStructName = x.Name
			return ce.defaultHandler
		}

	case *ast.StructType:
		return ce.elemTypeSpecHandler

	case *ast.FieldList:
		return ce.elemTypeSpecHandler

	case *ast.Field:
		return ce.elemTypeSpecHandler

	default:
		return ce.defaultHandler
	}
}
